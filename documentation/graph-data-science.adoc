= Graph Algorithms
:icons: font

// To Do
//
// - Replace doc links from the preview of 2.0 to current once they go live
// - Update all queries in /code
// - Something about what mutate is for, an example

== Neo4j Graph Data Science

The Neo4j Graph Data Science (GDS) library contains a set of graph algorithms, exposed through Cypher procedures.  Graph algorithms provide insights into the graph structure and elements, for example, by computing centrality, similarity scores, and detecting communities.  The GDS library is divided into three tiers of maturity: product, beta, and alpha.

This guide demonstrates the usual workflow for how to run production-tier algorithms.  The generalized workflow is as follows:app-name: 

* How to create a graph projection (also referred to as an "in-memory graph")
* How graph projections are used to run a graph algorithm with GDS
* Examples of running a few graph algorithms and interpretation of their results

The official GDS library documentation can be found link:https://neo4j.com/docs/graph-data-science/current/[here^].

== Graph Model

Before you run any of the algorithms, you need to import your data.  We will be working with an example dataset that shows the connections between different airports across the world. Note that we have 5 different node labels (`Airport`, `City`, `Country`, `Continent`, and `Region`) and 5 different relationship types (`:HAS_ROUTE`, `:IN_CITY`, `:IN_COUNTRY`, `:IN_REGION`, and `:ON_CONTINENT`).

*_Insert graph schema image here_*

// image::img/air_route_schema.png

image::https://s3.amazonaws.com/guides.neo4j.com/graph-data-science2/air_route_schema.png[float="right",width=300]

=== Attribution

This dataset was initially created by Kelvin Lawrence, available under the Apache License Version 2.0.  The original dataset can be found https://github.com/krlawrence/graph[GitHub repository] and has been modified for the purposes of this guide.

== Loading the data

We will use the Cypher command `LOAD CSV` to import our data into Neo4j from CSV file hosted on GitHub.  It will parse a CSV file line by line as objects that can then be manipulated using Cypher.  

We begin by creating uniqeness constraints on each of the nodes, which make for efficient queries.

[source,cypher]
----
CREATE CONSTRAINT airports ON (a:Airport) ASSERT a.iata IS UNIQUE;
CREATE CONSTRAINT cities ON (c:City) ASSERT c.name IS UNIQUE;
CREATE CONSTRAINT regions ON (r:Region) ASSERT r.name IS UNIQUE;
CREATE CONSTRAINT countries ON (c:Country) ASSERT c.code IS UNIQUE;
CREATE CONSTRAINT continents ON (c:Continent) ASSERT c.code IS UNIQUE;
----

Next we will import the Airport, Country, and Continent nodes and set their properties.

*_Redo this section such that we do not populate airport nodes with properties that then get used for nodes_*

[source,cypher]
----
WITH 
    'https://raw.githubusercontent.com/cj2001/bite_sized_data_science/main/data/airport-node-list.csv'
    AS url
LOAD CSV WITH HEADERS FROM url AS row
MERGE (a:Airport {iata: row.iata})
SET a.id = row.id,
    a.icao = row.icao,
    a.city = row.city,
    a.descr = row.descr,
    a.region = row.region,
    a.runways = toInteger(row.runways),
    a.longest = toInteger(row.longest),
    a.altitude = toInteger(row.altitude),
    a.country = row.country,
    a.continent = row.continent,
    a.lat = toFloat(row.lat),
    a.lon = toFloat(row.lon);

WITH 
    'https://raw.githubusercontent.com/cj2001/bite_sized_data_science/main/data/country-node-list.csv'
    AS url
LOAD CSV WITH HEADERS FROM url AS row
MERGE (c:Country {code: row.code})
SET c.descr = row.descr;

WITH 
    'https://raw.githubusercontent.com/cj2001/bite_sized_data_science/main/data/continent-node-list.csv'
    AS url
LOAD CSV WITH HEADERS FROM url AS row
MERGE (c:Continent {code: row.code})
SET c.descr = row.descr;
----

Finally, we will import all of our relationships.  Note that some of the relationships only exist in the Airport nodes list (in the CSV file).  We will use these to artifically create the City and Region nodes as well as the relationships between them and the Airport, Country, and Continent nodes.  Note that the `(Airport)-[:HAS_ROUTE]-(Airport)` relationship has a relationship property of `distance`, indicating the distance between each of the airports.  We will later use this to create weighted graphs.

[source,cypher]
----
LOAD CSV WITH HEADERS FROM 'https://raw.githubusercontent.com/cj2001/bite_sized_data_science/main/data/iroutes-edges.csv' AS row
MATCH (source:Airport {iata: row.src})
MATCH (target:Airport {iata: row.dest})
MERGE (source)-[r:HAS_ROUTE]->(target)
ON CREATE SET r.distance = toInteger(row.dist);

MATCH (a:Airport)
MERGE (c:City {name: a.city})
MERGE (a)-[:IN_CITY]->(c);

MATCH (a:Airport)
MERGE (r:Region {name: a.region})
MERGE (a)-[:IN_REGION]->(r);

MATCH (a:Airport)
MERGE (c:City {name: a.city})
MERGE (c)-[:IN_REGION]->(r);

MATCH (a:Airport)
MATCH (c:Country {code: a.country})
MERGE (a)-[:IN_COUNTRY]->(c);

MATCH (a:Airport)
MATCH (ci:City {name: a.city})
MATCH (co:Country {code: a.country})
MERGE (ci)-[:IN_COUNTRY]->(co);

MATCH (a:Airport)
MATCH (r:Region {name: a.region})
MATCH (co:Country {code: a.country})
MERGE (r)-[:IN_COUNTRY]->(co);

MATCH (a:Airport)
MATCH (c:Continent {code: a.continent})
MERGE (a)-[:ON_CONTINENT]->(c);

MATCH (a:Airport)
MATCH (ci:City {name: a.city})
MATCH (co:Continent {code: a.continent})
MERGE (ci)-[:ON_CONTINENT]->(co);

MATCH (a:Airport)
MATCH (r:Region {name: a.region})
MATCH (co:Continent {code: a.continent})
MERGE (r)-[:ON_CONTINENT]->(co);

MATCH (a:Airport)
MATCH (c:Country {code: a.country})
MATCH (co:Continent {code: a.continent})
MERGE (c)-[:ON_CONTINENT]->(co);
----

== Data visualization

Prior to running some algorithms, it is helpful to visualize our data.  In order to do so, running the following query, which will give you the schema of the graph:

[source,cypher]
----
CALL db.schema.visualization()
----

Using this command, we can see our 5 different node and relationship types.

== Summary statistics

Prior to using any of the GDS algorithms it can be beneficial to calculate some summary statistics on the data.  For example, the following calculate the minimum, maximum, average, and standard deviation of the number of flights out of each airport.

[source,cypher]
----
MATCH (a:Airport)-[:HAS_ROUTE]->()
WITH a, count(*) AS num
RETURN min(num) AS min, max(num) AS max, avg(num) AS avg_routes, stdev(num) AS stdev
----

// Note that we cannot repeat the same query as in the original browser guide because that
// graph had a property of "book" in its relationship.  We do not have the equivalent in 
// this graph.

== Graph creation

The first step in executing any GDS algorithm is to create a graph projection (also referred to as an in-memory graph) under a user-defined name.  Graph projections are subsets of our full graph to be used in calculating results through the GDS algorithms.  Their use enables GDS to run quickly and efficiently through the calculations.  In the creation of these projections, the nature of the graph elements may change in the following ways:

* Nodes and relationship types might be renamed
* Several node or relationship types might be merged
* The direction of relationships might be changed
* Parallel relationships might be aggregated
* Relationships might be derived from larger patterns

// I am leaving out the mention of subgraphs since that is a pretty complex topic

Graph projections can be created through one of two methods: native projections and Cypher projections.  These graph projections are then stored in the graph catalog under a user-defined name.

== Graph catalog: creating a graph with native projections

Native projections provide the fastest performance for creating an graph projection.  They take 3 mandatory arguments: `graphName`, 'nodeProjection', and 'relationshipProjection'.  There are also optional `configuration` parameters that can be used to further configure the graph.  In general, the syntax for creating a native projection is:

[source,cypher]
----
CALL gds.graph.project(
    graphName: String,
    nodeProjection: String or List or Map,
    relationshipProjection: String or List or Map,
    configuration: Map
)
YIELD
  graphName: String,
  nodeProjection: Map,
  nodeCount: Integer,
  relationshipProjection: Map,
  relationshipCount: Integer,
  projectMillis: Integer,
  createMillis: Integer
----

== Example of a native projection

In our dataset, we could create a graph projection of the routes between all airports as:

[source,cypher]
----
CALL gds.graph.project(
    'routes',
    'Airport',
    'HAS_ROUTE'
)
YIELD
    graphName, nodeProjection, nodeCount, relationshipProjection, relationshipCount
----

This is a very simple graph projection, but it is possible to add multiple node types and relationship types as well as properties for each of the nodes and relationships.  To see more examples of creating native graph projections, consult the link:https://neo4j.com/docs/graph-data-science/2.0-preview/graph-project/#graph-project-examples[GDS documentation^].

== Graph catalog: creating a graph with Cypher projections

There are times where native projections are not expressive enough to capture exactly what you need in the graph.  In these cases, Cypher can be used to create the graph projection.  The overall syntax for this is:

[source,cypher]
----
CALL gds.graph.project.cypher(
    graphName: String,
    nodeQuery: String,
    relationshipQuery: String,
    configuration: Map
) YIELD
    graphName: String,
    nodeQuery: String,
    nodeCount: Integer,
    relationshipQuery: String,
    relationshipCount: Integer,
    projectMillis: Integer,
    createMillis: Integer,
----

The difference between this and the native projection is that the node and relationships projections are replaced with Cypher statements.

== Example of a Cypher projection

[source,cypher]
----
CALL gds.graph.project.cypher(
    'routes_cypher',
    'MATCH (a:Airport) RETURN id(a) AS id',
    'MATCH (a1:Airport)-[:HAS_ROUTE]->(a2:Airport) RETURN id(a1) AS source, id(a2) AS target'
)
YIELD
    graphName, nodeProjection, nodeCount, relationshipProjection, relationshipCount
----

We can see here that Cypher projections work with the internal `id` of each node, which is returned in the node query and then used in the relationship query.  Note that GDS requires the specification of the `source` and `target` nodes in the relationship query.

By using Cypher projections, we can specify many things, such as requirements on the node and relationship properties and more sophisticated relationships.  To see more examples of creating Cypher graph projections, consult the link:https://neo4j.com/docs/graph-data-science/2.0-preview/graph-project-cypher/#graph-project-examples[GDS documentation^].


== Graph catalog: listing and existence

It is helpful to know which graphs are in the catalog and their properties.  To see this for all graphs, you use

[source,cypher]
----
CALL gds.graph.list()
----

You can also check this for an individual graph using:

[source,cypher]
----
CALL gds.graph.list('graph-name')
----

where `graph-name` is the name of your projected, in-memory graph.


== Graph catalog: dropping a graph

Once you are done using a projected graph, it is beneficial to drop it from the catalog in order to free up memory space.  This can be achieved by using:

[source,cypher]
----
CALL gds.graph.drop('graph-name')
----

where `graph-name` is the name of your projected, in-memory graph.

== Getting started with algorithms

== Algorithm syntax: available execution modes

Once you have created a named graph projection, there are 4 different execution modes provided for each algorithm:

* `stream`: Returns the results of the algorithm as a stream of records without altering the database
* `write`: Writes the results of the algorithm to the Neo4j database and returns a single record of summary statistics
* `mutate`: Writes the results of the algorithm to the projected graph and returns a single record of summary statistics
* `stats`: Returns a single record of summary statistics but does not write to either the Neo4j database or the projected graph 

In addition to the above for modes, it is possible to use `estimate` to obtain an estimation of how much memory a given algorithm will use.

== Algorithm syntax: general algorithm use

Utilizing one of the 4 different execution modes, the general way to call a graph algorithm is as follows:

[source,cypher]
----
CALL gds[.<tier>].<algorithm>.<execution-mode>[.<estimate>](
  graphName: String,
  configuration: Map
)
----

where items in `[]` are optional.  From the above, `<tier>`, if present, indicates whether the algorithm is in the alpha or beta tier (production-tiered algorithms do not use this), `<algorithm>` is the name of the algorithm, `<execution-mode>` is one of the 4 execution modes, and `<estimate>` is an optional flag indicating that the estimate of memory usage should be returned.

== Interpretting results of an algorithm

GDS uses an internal `id` space for its calculations, which does not correspond to recognizable information of the graph itself.  As such, when we return results from an algorithm, it is returned in the `id` space.  We generally want to convert this to something coresponding to our actual graph.  To do so, we use the built in method:

`gds.util.asNode(nodeId).property_name AS property_name`

which will extract the desired `property_name` from the graph projection based on the `id` space.  We will see examples of this shortly.

== Centrality measurements via PageRank

image::https://upload.wikimedia.org/wikipedia/commons/thumb/f/fb/PageRanks-Example.svg/758px-PageRanks-Example.svg.png[float="right", width="300"]

There are many ways to determine the centrality or importance of a node, but one of the most popular is through the calculation of PageRank.  PageRank measures the transitive (or directional) influence of a node.  The benefit to this approach is that it uses the influence of a node's neighbors to determine the influence of the target node.  The general idea is that a node that has more incoming and more influential links from other nodes is considered to be more important (i.e. a higher PageRank).

The algorithm itself is an iterative algorithm.  The number of iterations can be set as a configuration parameter in GDS, however the algorithm can terminate if the node scores converge based on a specified tolerance value, which is also configurable in GDS.

PageRank can be run on a basic graph, such as what we are using here, or with a weighted graph.  To see how to run it on a weighted graph, please explore the link:https://neo4j.com/docs/graph-data-science/2.0-preview/algorithms/page-rank/#algorithms-page-rank-examples-weighted[GDS documentation^].

== PageRank example graph

We will utilize the `routes` graph projection that we wrote before.  If you need to recreate that graph projection, you can do so with the following:

[source,cypher]
----
CALL gds.graph.project(
    'routes',
    'Airport',
    'HAS_ROUTE'
)
YIELD
    graphName, nodeProjection, nodeCount, relationshipProjection, relationshipCount
----

== PageRank: stream mode

As previously stated, stream mode will output the results of the calculation without altering the database or the graph projection.  To do so, we use:

[source,cypher]
----
CALL gds.pageRank.stream('routes')
YIELD nodeId, score
RETURN gds.util.asNode(nodeId).iata AS iata, score
ORDER BY score DESC, iata ASC
----

Here we see that we have returned the results of the calculation, mapped in the internal `id` space, as well as the PageRank score.  We then extract the `iata` code of the airport from the `id` space using `gds.util.asNode()`.  We can see that the output is the airport codes, ordered by decreasing PageRank score.  The airports with the highest PageRank scores are very popular airports around the globe, as we would expect.

== PageRank: write mode

If we want to attach the results of the PageRank calculation as a node property to each node in the graph, we would use `.write()` as follows:

[source,cypher]
----
CALL gds.pageRank.write('routes', 
    {
        writeProperty: 'pagerank'
    }
)
YIELD nodePropertiesWritten, ranIterations
----

We can then confirm the results using:

[source,cypher]
----
MATCH (a:Airport)
RETURN a.iata, a.pagerank
ORDER BY a.pagerank DESC, a.iata ASC
----

As we can see, the results are identical to the streamed version.

== Community (cluster) detection via Louvain Modularity

As with centrality measurements, there are many ways to identify communities within a graph.  We will cover the popular Louvain Modularity method in this section.  This algorithm finds clusters within a graph by measuring the density of nodes.  This is quantified through the _modularity_, which is a comparison of the density of connections within a cluster to an average or random sample.  So the higher the modularity, the more dense the cluster is.  The Louvain method thus attempts to maximize the modularity across the graph through a recursive approach.  As with PageRank, in GDS the user can specify a maximum number of iterations as well as a tolerance factor for early termination.  Additionally, the algorithm is able to return the intermediate community assignments along the way to convergence.  

== Louvain example graph

We will utilize the `routes` graph projection that we wrote before.  If you need to recreate that graph projection, you can do so with the following:

[source,cypher]
----
CALL gds.graph.project(
    'routes',
    'Airport',
    'HAS_ROUTE'
)
YIELD
    graphName, nodeProjection, nodeCount, relationshipProjection, relationshipCount
----

== Louvain: example

Using the stream mode, let's explore the results of the algorithm.  We will use the following query:

[source,cypher]
----
CALL gds.louvain.stream('routes')
YIELD nodeId, communityId
RETURN 
	communityId,
    SIZE(COLLECT(gds.util.asNode(nodeId).iata)) AS number_of_airports,
	COLLECT(gds.util.asNode(nodeId).city) AS city
ORDER BY number_of_airports DESC, communityId;
----

In this case we have obtained the community IDs and counted the number of airports, by `iata` code, in each community using the combination of `COLLECT`, which creates a list of the results, and `SIZE`, which returns the size of a list.  We also return a list of the cities in each community.  

Exploring this list, we can see that the largest community corresponds to airports in the United States, the second largest to airports in Europe, and so on.  At surface inspection, these results make sense in that the airports in the graph appear to be clustered based on continent.

As before, should we wish to write these results as node properties, we can use `gds.louvain.write()`.

== Node similarity

== Node similarity: example graph

== Node similarity: simple run

== Node similarity: similarity cutoff

== Node similarity: topN

== Node similarity: topK

== Node similarity exercise

// bottomN and bottomK

==  Node similarity exercise solution

== The end

// We have not shown anything on a weighted graph...make a comment on this 







